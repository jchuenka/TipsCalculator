//
//  TipsyMocks.generated.swift
//  Tipsy
//
//  Generated by Mockingbird v0.11.1.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import Tipsy
import Foundation
import Swift
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Tipsy.AppDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AppDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked `application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions)

  public override func `application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`connectingSceneSession`), Mockingbird.ArgumentMatcher(`options`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration {
      return concreteImplementation(`application`, `connectingSceneSession`, `options`)
    } else {
      return (implementation as! () -> UISceneConfiguration)()
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `configurationForConnecting` `connectingSceneSession`: @escaping @autoclosure () -> UISceneSession, `options`: @escaping @autoclosure () -> UIScene.ConnectionOptions) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration, UISceneConfiguration> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`connectingSceneSession`), Mockingbird.resolve(`options`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration, UISceneConfiguration>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>)

  public override func `application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`sceneSessions`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIApplication, Set<UISceneSession>) -> Void {
      concreteImplementation(`application`, `sceneSessions`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `didDiscardSceneSessions` `sceneSessions`: @escaping @autoclosure () -> Set<UISceneSession>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, Set<UISceneSession>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`sceneSessions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, Set<UISceneSession>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?)

  public override func `application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`launchOptions`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
      return concreteImplementation(`application`, `launchOptions`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: @escaping @autoclosure () -> [UIApplication.LaunchOptionsKey: Any]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`launchOptions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `Tipsy.AppDelegate`.
public func mock(_ type: Tipsy.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock.InitializerProxy.Type {
  return AppDelegateMock.InitializerProxy.self
}

// MARK: - Mocked BillEngineInterface

public final class BillEngineInterfaceMock: Tipsy.BillEngineInterface, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BillEngineInterfaceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked amountPreTaxDisplay

  public var `amountPreTaxDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTaxDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getAmountPreTaxDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTaxDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked amountPreTax

  public var `amountPreTax`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getAmountPreTax() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setAmountPreTax(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitAmountDisplay

  public var `splitAmountDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitAmountDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getSplitAmountDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitAmountDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitDisplay

  public var `splitDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getSplitDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitNumber

  public var `splitNumber`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSplitNumber() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  public func setSplitNumber(_ newValue: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked taxDisplay

  public var `taxDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getTaxDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked taxPercent

  public var `taxPercent`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTaxPercent() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setTaxPercent(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked tipDisplay

  public var `tipDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getTipDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked tipsPercent

  public var `tipsPercent`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTipsPercent() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setTipsPercent(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getSplitAmount`()

  public func `getSplitAmount`() -> Float {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getSplitAmount`() -> Float", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Float {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Float)()
    }
  }

  public func `getSplitAmount`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getSplitAmount`() -> Float", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `Tipsy.BillEngineInterface`.
public func mock(_ type: Tipsy.BillEngineInterface.Protocol, file: StaticString = #file, line: UInt = #line) -> BillEngineInterfaceMock {
  return BillEngineInterfaceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked BillEngine

public final class BillEngineMock: Tipsy.BillEngine, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BillEngineMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`billInfo`: Tipsy.BillInfo, `split`: Int, __file: StaticString = #file, __line: UInt = #line) -> BillEngineMock {
      let mock: BillEngineMock = BillEngineMock(billInfo: `billInfo`, split: `split`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked amountPreTaxDisplay

  override public var `amountPreTaxDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTaxDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getAmountPreTaxDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTaxDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked amountPreTax

  override public var `amountPreTax`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getAmountPreTax() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setAmountPreTax(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitAmountDisplay

  override public var `splitAmountDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitAmountDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getSplitAmountDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitAmountDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitDisplay

  override public var `splitDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getSplitDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitNumber

  override public var `splitNumber`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSplitNumber() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  public func setSplitNumber(_ newValue: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumber.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked taxDisplay

  override public var `taxDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getTaxDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked taxPercent

  override public var `taxPercent`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTaxPercent() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setTaxPercent(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked tipDisplay

  override public var `tipDisplay`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipDisplay.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getTipDisplay() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipDisplay.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked tipsPercent

  override public var `tipsPercent`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTipsPercent() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setTipsPercent(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipsPercent.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getSplitAmount`()

  public override func `getSplitAmount`() -> Float {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getSplitAmount`() -> Float", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Float {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Float)()
    }
  }

  public func `getSplitAmount`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getSplitAmount`() -> Float", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`billInfo`: Tipsy.BillInfo, `split`: Int)

  public required override init(`billInfo`: Tipsy.BillInfo, `split`: Int) {
    super.init(billInfo: `billInfo`, split: `split`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`billInfo`: Tipsy.BillInfo, `split`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`billInfo`), Mockingbird.ArgumentMatcher(`split`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `Tipsy.BillEngine`.
public func mock(_ type: Tipsy.BillEngine.Type, file: StaticString = #file, line: UInt = #line) -> BillEngineMock.InitializerProxy.Type {
  return BillEngineMock.InitializerProxy.self
}

// MARK: - Mocked BillInfo

public final class BillInfoMock: Tipsy.BillInfo, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BillInfoMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> BillInfoMock {
      let mock: BillInfoMock = BillInfoMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked amountPreTax

  override public var `amountPreTax`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getAmountPreTax() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setAmountPreTax(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountPreTax.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked taxPercent

  override public var `taxPercent`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTaxPercent() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setTaxPercent(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxPercent.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked tipPercent

  override public var `tipPercent`: Float {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipPercent.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Float)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipPercent.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Float) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTipPercent() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipPercent.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  public func setTipPercent(_ newValue: @escaping @autoclosure () -> Float) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tipPercent.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Float) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `Tipsy.BillInfo`.
public func mock(_ type: Tipsy.BillInfo.Type, file: StaticString = #file, line: UInt = #line) -> BillInfoMock.InitializerProxy.Type {
  return BillInfoMock.InitializerProxy.self
}

// MARK: - Mocked ResultViewController

public final class ResultViewControllerMock: Tipsy.ResultViewController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ResultViewControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> ResultViewControllerMock? {
      let mock: ResultViewControllerMock? = ResultViewControllerMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> ResultViewControllerMock {
      let mock: ResultViewControllerMock = ResultViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked resultLabel

  override public var `resultLabel`: UIKit.UILabel! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "resultLabel.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIKit.UILabel)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "resultLabel.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIKit.UILabel) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getResultLabel() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIKit.UILabel, UIKit.UILabel> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "resultLabel.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIKit.UILabel, UIKit.UILabel>(mock: self, invocation: invocation)
  }

  public func setResultLabel(_ newValue: @escaping @autoclosure () -> UIKit.UILabel) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIKit.UILabel) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "resultLabel.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIKit.UILabel) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitDescLable

  override public var `splitDescLable`: UIKit.UILabel! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDescLable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIKit.UILabel)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDescLable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIKit.UILabel) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSplitDescLable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIKit.UILabel, UIKit.UILabel> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDescLable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIKit.UILabel, UIKit.UILabel>(mock: self, invocation: invocation)
  }

  public func setSplitDescLable(_ newValue: @escaping @autoclosure () -> UIKit.UILabel) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIKit.UILabel) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitDescLable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIKit.UILabel) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `initilize`(_ `engine`: Tipsy.BillEngineInterface)

  public override func `initilize`(_ `engine`: Tipsy.BillEngineInterface) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`initilize`(_ `engine`: Tipsy.BillEngineInterface) -> Void", arguments: [Mockingbird.ArgumentMatcher(`engine`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Tipsy.BillEngineInterface) -> Void {
      concreteImplementation(`engine`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `initilize`(_ `engine`: @escaping @autoclosure () -> Tipsy.BillEngineInterface) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Tipsy.BillEngineInterface) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`engine`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`initilize`(_ `engine`: Tipsy.BillEngineInterface) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Tipsy.BillEngineInterface) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `recalculateButtonPressed`(_ `sender`: UIButton)

  public override func `recalculateButtonPressed`(_ `sender`: UIButton) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`recalculateButtonPressed`(_ `sender`: UIButton) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sender`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIButton) -> Void {
      concreteImplementation(`sender`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `recalculateButtonPressed`(_ `sender`: @escaping @autoclosure () -> UIButton) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIButton) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sender`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`recalculateButtonPressed`(_ `sender`: UIButton) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIButton) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `viewDidLoad`()

  public override func `viewDidLoad`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`viewDidLoad`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `viewDidLoad`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`viewDidLoad`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `Tipsy.ResultViewController`.
public func mock(_ type: Tipsy.ResultViewController.Type, file: StaticString = #file, line: UInt = #line) -> ResultViewControllerMock.InitializerProxy.Type {
  return ResultViewControllerMock.InitializerProxy.self
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Tipsy.SceneDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SceneDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked window

  override public var `window`: UIWindow? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIWindow?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIWindow?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWindow() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIWindow?, UIWindow?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIWindow?, UIWindow?>(mock: self, invocation: invocation)
  }

  public func setWindow(_ newValue: @escaping @autoclosure () -> UIWindow?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIWindow?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIWindow?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions)

  public override func `scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`), Mockingbird.ArgumentMatcher(`session`), Mockingbird.ArgumentMatcher(`connectionOptions`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void {
      concreteImplementation(`scene`, `session`, `connectionOptions`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `scene`(_ `scene`: @escaping @autoclosure () -> UIScene, `willConnectTo` `session`: @escaping @autoclosure () -> UISceneSession, `options` `connectionOptions`: @escaping @autoclosure () -> UIScene.ConnectionOptions) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`), Mockingbird.resolve(`session`), Mockingbird.resolve(`connectionOptions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidBecomeActive`(_ `scene`: UIScene)

  public override func `sceneDidBecomeActive`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidBecomeActive`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneDidBecomeActive`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidBecomeActive`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidDisconnect`(_ `scene`: UIScene)

  public override func `sceneDidDisconnect`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidDisconnect`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneDidDisconnect`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidDisconnect`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidEnterBackground`(_ `scene`: UIScene)

  public override func `sceneDidEnterBackground`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidEnterBackground`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneDidEnterBackground`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidEnterBackground`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneWillEnterForeground`(_ `scene`: UIScene)

  public override func `sceneWillEnterForeground`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillEnterForeground`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneWillEnterForeground`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillEnterForeground`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneWillResignActive`(_ `scene`: UIScene)

  public override func `sceneWillResignActive`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillResignActive`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneWillResignActive`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillResignActive`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `Tipsy.SceneDelegate`.
public func mock(_ type: Tipsy.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock.InitializerProxy.Type {
  return SceneDelegateMock.InitializerProxy.self
}

// MARK: - Mocked TipCalculatorViewController

public final class TipCalculatorViewControllerMock: Tipsy.TipCalculatorViewController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "Tipsy"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TipCalculatorViewControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> TipCalculatorViewControllerMock? {
      let mock: TipCalculatorViewControllerMock? = TipCalculatorViewControllerMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> TipCalculatorViewControllerMock {
      let mock: TipCalculatorViewControllerMock = TipCalculatorViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked amountField

  override public var `amountField`: UITextField! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountField.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UITextField)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountField.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UITextField) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getAmountField() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UITextField, UITextField> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountField.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UITextField, UITextField>(mock: self, invocation: invocation)
  }

  public func setAmountField(_ newValue: @escaping @autoclosure () -> UITextField) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UITextField) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "amountField.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UITextField) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked billEngine

  override public var `billEngine`: Tipsy.BillEngineInterface? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "billEngine.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Tipsy.BillEngineInterface?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "billEngine.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Tipsy.BillEngineInterface?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getBillEngine() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Tipsy.BillEngineInterface?, Tipsy.BillEngineInterface?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "billEngine.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Tipsy.BillEngineInterface?, Tipsy.BillEngineInterface?>(mock: self, invocation: invocation)
  }

  public func setBillEngine(_ newValue: @escaping @autoclosure () -> Tipsy.BillEngineInterface?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Tipsy.BillEngineInterface?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "billEngine.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Tipsy.BillEngineInterface?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked personStepper

  override public var `personStepper`: UIStepper! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "personStepper.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIStepper)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "personStepper.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIStepper) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getPersonStepper() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIStepper, UIStepper> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "personStepper.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIStepper, UIStepper>(mock: self, invocation: invocation)
  }

  public func setPersonStepper(_ newValue: @escaping @autoclosure () -> UIStepper) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIStepper) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "personStepper.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIStepper) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked splitNumberLabel

  override public var `splitNumberLabel`: UIKit.UILabel! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumberLabel.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIKit.UILabel)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumberLabel.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIKit.UILabel) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSplitNumberLabel() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIKit.UILabel, UIKit.UILabel> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumberLabel.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIKit.UILabel, UIKit.UILabel>(mock: self, invocation: invocation)
  }

  public func setSplitNumberLabel(_ newValue: @escaping @autoclosure () -> UIKit.UILabel) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIKit.UILabel) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "splitNumberLabel.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIKit.UILabel) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked taxField

  override public var `taxField`: UITextField! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxField.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UITextField)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxField.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UITextField) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTaxField() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UITextField, UITextField> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxField.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UITextField, UITextField>(mock: self, invocation: invocation)
  }

  public func setTaxField(_ newValue: @escaping @autoclosure () -> UITextField) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UITextField) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "taxField.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UITextField) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked tenPercentButton

  override public var `tenPercentButton`: UIButton! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tenPercentButton.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIButton)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tenPercentButton.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIButton) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTenPercentButton() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIButton, UIButton> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tenPercentButton.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIButton, UIButton>(mock: self, invocation: invocation)
  }

  public func setTenPercentButton(_ newValue: @escaping @autoclosure () -> UIButton) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIButton) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "tenPercentButton.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIButton) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked twentyPercentButon

  override public var `twentyPercentButon`: UIButton! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "twentyPercentButon.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIButton)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "twentyPercentButon.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIButton) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTwentyPercentButon() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIButton, UIButton> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "twentyPercentButon.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIButton, UIButton>(mock: self, invocation: invocation)
  }

  public func setTwentyPercentButon(_ newValue: @escaping @autoclosure () -> UIButton) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIButton) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "twentyPercentButon.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIButton) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked zeroPercentButton

  override public var `zeroPercentButton`: UIButton! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "zeroPercentButton.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIButton)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "zeroPercentButton.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIButton) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getZeroPercentButton() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIButton, UIButton> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "zeroPercentButton.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIButton, UIButton>(mock: self, invocation: invocation)
  }

  public func setZeroPercentButton(_ newValue: @escaping @autoclosure () -> UIButton) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIButton) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "zeroPercentButton.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIButton) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `amountFieldEditEnded`(_ `sender`: UITextField)

  public override func `amountFieldEditEnded`(_ `sender`: UITextField) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`amountFieldEditEnded`(_ `sender`: UITextField) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sender`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UITextField) -> Void {
      concreteImplementation(`sender`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `amountFieldEditEnded`(_ `sender`: @escaping @autoclosure () -> UITextField) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UITextField) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sender`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`amountFieldEditEnded`(_ `sender`: UITextField) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UITextField) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `calculateButtonPress`(_ `sender`: Any)

  public override func `calculateButtonPress`(_ `sender`: Any) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`calculateButtonPress`(_ `sender`: Any) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sender`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any) -> Void {
      concreteImplementation(`sender`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `calculateButtonPress`(_ `sender`: @escaping @autoclosure () -> Any) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sender`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`calculateButtonPress`(_ `sender`: Any) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `handleKeyboardShow`(_ `notification`: NSNotification)

  public override func `handleKeyboardShow`(_ `notification`: NSNotification) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`handleKeyboardShow`(_ `notification`: NSNotification) -> Void", arguments: [Mockingbird.ArgumentMatcher(`notification`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (NSNotification) -> Void {
      concreteImplementation(`notification`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `handleKeyboardShow`(_ `notification`: @escaping @autoclosure () -> NSNotification) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (NSNotification) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`notification`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`handleKeyboardShow`(_ `notification`: NSNotification) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (NSNotification) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `personStepperValueChanged`(_ `sender`: UIStepper)

  public override func `personStepperValueChanged`(_ `sender`: UIStepper) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`personStepperValueChanged`(_ `sender`: UIStepper) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sender`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIStepper) -> Void {
      concreteImplementation(`sender`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `personStepperValueChanged`(_ `sender`: @escaping @autoclosure () -> UIStepper) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIStepper) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sender`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`personStepperValueChanged`(_ `sender`: UIStepper) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIStepper) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `taxFieldEditEnded`(_ `sender`: UITextField)

  public override func `taxFieldEditEnded`(_ `sender`: UITextField) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`taxFieldEditEnded`(_ `sender`: UITextField) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sender`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UITextField) -> Void {
      concreteImplementation(`sender`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `taxFieldEditEnded`(_ `sender`: @escaping @autoclosure () -> UITextField) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UITextField) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sender`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`taxFieldEditEnded`(_ `sender`: UITextField) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UITextField) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `tipButtonPress`(_ `sender`: UIButton)

  public override func `tipButtonPress`(_ `sender`: UIButton) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`tipButtonPress`(_ `sender`: UIButton) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sender`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIButton) -> Void {
      concreteImplementation(`sender`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `tipButtonPress`(_ `sender`: @escaping @autoclosure () -> UIButton) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIButton) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sender`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`tipButtonPress`(_ `sender`: UIButton) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIButton) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `viewDidLoad`()

  public override func `viewDidLoad`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`viewDidLoad`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `viewDidLoad`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`viewDidLoad`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `Tipsy.TipCalculatorViewController`.
public func mock(_ type: Tipsy.TipCalculatorViewController.Type, file: StaticString = #file, line: UInt = #line) -> TipCalculatorViewControllerMock.InitializerProxy.Type {
  return TipCalculatorViewControllerMock.InitializerProxy.self
}
